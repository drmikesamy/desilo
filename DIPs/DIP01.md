DIP-01
======

Basic protocol flow description
-------------------------------

`draft` `mandatory`

This DIP defines the basic protocol that should be implemented by all healthcare providers. New Desilo Improvements (DIPs) may add new optional (or mandatory) fields, messages, and features to the structures and flows described here.

## Note-Summaries

Clinicians can send Note-Summaries to a DCache they control, or a DCache of another provider who has authorised that clinician to send them Note-Summaries. Each time a clinician accesses the Desilo client, a temporary RSA (secp256r1) key pair is generated by the client they are using. The private key remains in the client for its lifetime. As part of the login to the Desilo Authentication Service, they transmit the public key to the Authentication Service, which has the authority to record it to their .well-known public information. Over time, every public key they use to record information will be logged for future message signature verification.

The only object type that exists in Desilo is the `NoteSummary`, which has the following format:

```jsonc
{
  "Id": <32-bytes lowercase hex-encoded sha256 of the serialized Summary-Note data>,
  "Author": <32-bytes lowercase hex-encoded public key of the Summary-Note creator>,
  "CreatedDate": <unix timestamp in seconds>,
  "Kind": <integer between 0 and 65535>,
  "Tags": [
    {"Key": <Identifier>, "Value": <arbitrary string>},
    // ...
  ],
  "Content": <FHIR standardised string>,
  "Signature": <64-bytes lowercase hex of the signature of the sha256 hash of the serialized Summary-Note data, which is the same as the "Id" field>
}
```

To obtain the `NoteSummary.Id`, we `sha256` the serialized note-summary. The `sha256` is done over the UTF-8 JSON-serialized string (which is described below) of the following structure:

```jsonc
{
  "Id": <EMPTY STRING>,
  "Author": <32-bytes lowercase hex-encoded public key of the Summary-Note creator>,
  "CreatedDate": <unix timestamp in seconds>,
  "Kind": <integer between 0 and 65535>,
  "Tags": [
    {"Key": <Identifier>, "Value": <arbitrary string>},
    // ...
  ],
  "Content": <FHIR standardised string>,
  "Signature": <EMPTY STRING>
}
```

Once we have the note-summary Id string, we populate it, `sha256` the UTF-8 JSON-serialized string with the Id included and generate an ECDSA signature, using the client private key, of that JSON string. Finally, we populate the original Note-Summary object with the signature and the Note-Summary can now be verified.

To prevent implementation differences from creating a different Summary-Note ID for the same event, the following rules MUST be followed while serializing:
- UTF-8 should be used for encoding.
- Whitespace, line breaks or other unnecessary formatting should not be included in the output JSON.
- The following characters in the content field must be escaped as shown, and all other characters must be included verbatim:
  - A line break (`0x0A`), use `\n`
  - A double quote (`0x22`), use `\"`
  - A backslash (`0x5C`), use `\\`
  - A carriage return (`0x0D`), use `\r`
  - A tab character (`0x09`), use `\t`
  - A backspace, (`0x08`), use `\b`
  - A form feed, (`0x0C`), use `\f`

### Tags

Tags are used to help sort through Note-Summaries. They are simple key-value pairs.

```jsonc
{
  "Tags": [
    {"Key": "RootNote", "Value": "4a6f3b1c4b2a9f8d7e6c1a3e5b7f8d4e9b3a2c7d8e5f9a6b0c1d2e3f4a5b6c7"},
    {"Key": "Clinician", "Value": "e4d3c2b1a0987654321f0e1d2c3b4a5b6c7d8e9fa0b1c2d3e4f5a6b7c8d9e0f"},
    {"Key": "Referral", "Value": "8f7e6d5c4b3a29108f7e6d5c4b3a29108f7e6d5c4b3a2910c1d2e3f4b5a6978"},
    // ...
  ],
  // ...
}
```

### Kinds

Kinds specify how clients should interpret the meaning of each Note-Summary. A `kind:0` Note-Summary is basic patient details:

```jsonc
{
  "resourceType": "Patient",
  "id": "example",
  "identifier": [
    {
      "use": "official",
      "type": {
        "coding": [
          {
            "system": "http://terminology.hl7.org/CodeSystem/v2-0203",
            "code": "MR",
            "display": "Medical Record Number"
          }
        ]
      },
      "system": "http://hospital.smarthealthit.org",
      "value": "12345"
    }
  ],
  "active": true,
  "name": [
    {
      "use": "official",
      "family": "Doe",
      "given": [
        "John",
        "A"
      ]
    },
    {
      "use": "usual",
      "given": [
        "Johnny"
      ]
    }
  ],
  "telecom": [
    {
      "system": "phone",
      "value": "(555) 555-5555",
      "use": "home"
    },
    {
      "system": "email",
      "value": "john.doe@example.com",
      "use": "work"
    }
  ],
  "gender": "male",
  "birthDate": "1980-01-01",
  "address": [
    {
      "use": "home",
      "line": [
        "123 Main St"
      ],
      "city": "Anytown",
      "state": "CA",
      "postalCode": "12345",
      "country": "USA"
    }
  ],
  "contact": [
    {
      "relationship": [
        {
          "coding": [
            {
              "system": "http://terminology.hl7.org/CodeSystem/v2-0131",
              "code": "N",
              "display": "Next of Kin"
            }
          ]
        }
      ],
      "name": {
        "family": "Doe",
        "given": [
          "Jane"
        ]
      },
      "telecom": [
        {
          "system": "phone",
          "value": "(555) 555-1234",
          "use": "mobile"
        }
      ],
      "address": {
        "line": [
          "456 Main St"
        ],
        "city": "Anytown",
        "state": "CA",
        "postalCode": "12345",
        "country": "USA"
      },
      "gender": "female"
    }
  ],
  "managingOrganization": {
    "reference": "Organization/1",
    "display": "Anytown Hospital"
  }
}

```
A `kind:1` Note-Summary is a simple text entry, like a GP would enter after seeing a patient.

A `kind:2` Note-Summary is a Past Medical History and the Content field would be represented in FHIR format like so. Kinds can be expanded on and there will be standardised kinds things like serialised ECG data:

```jsonc
{
  "resourceType": "Condition",
  "id": "example",
  "clinicalStatus": {
    "coding": [
      {
        "system": "http://terminology.hl7.org/CodeSystem/condition-clinical",
        "code": "active"
      }
    ]
  },
  "verificationStatus": {
    "coding": [
      {
        "system": "http://terminology.hl7.org/CodeSystem/condition-ver-status",
        "code": "confirmed"
      }
    ]
  },
  "category": [
    {
      "coding": [
        {
          "system": "http://terminology.hl7.org/CodeSystem/condition-category",
          "code": "problem-list-item",
          "display": "Problem List Item"
        }
      ]
    }
  ],
  "code": {
    "coding": [
      {
        "system": "http://snomed.info/sct",
        "code": "44054006",
        "display": "Diabetes mellitus type 2"
      }
    ]
  },
  "subject": {
    "reference": "Patient/example"
  },
  "onsetDateTime": "2010-03-01",
  "recordedDate": "2023-02-22"
}
```

## Communication between clients and DCaches

DCaches expose a websocket endpoint to which clients can connect. Clients SHOULD open a single websocket connection to each DCache and use it for all their subscriptions. Relays MAY limit number of connections from specific IP/client/etc.

### From client to DCache: sending Summary-Notes and creating subscriptions

Clients can send 3 types of messages, which must be JSON arrays, according to the following patterns:

  * `{"Type": "NoteSummary", "Payload": <Summary-Note JSON as defined above>}`, used to publish Note-Summaries to a given DCache.
  * `{"Type": "Req", "SubscriptionId": <subscription_id>, "Filters": [<filters1>, <filters2>, ...]}`, used to request Note-Summaries and subscribe to new updates.
  * `{"Type": "Close", "SubscriptionId": <subscription_id>}`, used to stop previous subscriptions.

`<subscription_id>` is an arbitrary, non-empty string of max length 64 chars. It represents a subscription per connection. DCaches MUST manage `<subscription_id>`s independently for each WebSocket connection. `<subscription_id>`s are not guaranteed to be globally unique.

`<filtersX>` is a JSON object that determines what Note-Summaries will be sent in that subscription, it can have the following attributes:

```json
{
  "Ids": "<a list of Note-Summary ids>",
  "PatientId": "<patient id>",
  "Authors": "<a list of lowercase pubkeys, the pubkey of a Note-Summary must be one of these>",
  "Kinds": "<a list of kind numbers>",
  "Tags": [{"Key": "<tag key>", "Value": "<search criteria for given tag>"}],
  "Since": "<an integer unix timestamp in seconds. Events must have a created_at >= to this to pass>",
  "Until": "<an integer unix timestamp in seconds. Events must have a created_at <= to this to pass>",
  "Limit": "<maximum number of Note-Summary relays SHOULD return in the initial query>"
}
```

Upon receiving a `REQ` message, the relay SHOULD return Note-Summaries that match the filter. Any new Note-Summaries it receives SHOULD be sent to that same websocket until the connection is closed, a `CLOSE` Note-Summary is received with the same `<subscription_id>`, or a new `REQ` is sent using the same `<subscription_id>` (in which case a new subscription is created, replacing the old one).

Lists of Filter objects containing different criteria can be submitted. These should be treated with an OR operator approach.

### From DCache to client: sending Note-Summaries and notices

DCaches can send 5 types of messages, which must also be JSON arrays, according to the following patterns:

```json
{
  "Type": "NoteSummary",
  "SubscriptionId": "<subscriptionId>",
  "NoteSummary": "<NoteSummary JSON as defined above>"
},
{
  "Type": "OK",
  "NoteSummaryId": "<eventId>",
  "Result": "<true|false>",
  "Message": "<message>"
},
{
  "Type": "EndOfStream",
  "SubscriptionId": "<subscriptionId>"
},
{
  "Type": "Closed",
  "SubscriptionId": "<subscriptionId>",
  "Message": "<message>"
},
{
  "Type": "Notice",
  "Message": "<message>"
}
```
